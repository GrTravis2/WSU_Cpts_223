# CptS 223 PA3 - AVL Map vs std::map - Gavin Travis

## Does the custom avl map guarantee logarithmic insertion and lookup?
- Yes, I believe my custom avl map supports both logarithmic insertion and lookup, and I know this by comparing against the std::map implementation which according to [cppreference.com](https://en.cppreference.com/w/cpp/container/map/find) has time complexity of O(log n). Across the 1000 samples on average the avl_map find operation was returning the iterator to the element faster than std::map find operation. After running the simulation 5 times the average difference between the two collections found the avl_map was faster by about 6.00*10^7 seconds. While this difference in find duration is very small I think it is fair to say that the two collections are comparable in performance. While I only tested find() over a large sample set, and not insert() I can still guarantedd O(log n) time for insert since they share the same searching algorithm. The additional time to attach the new node and resolve balance is independant of collection size so insert will be the same time complexity as find()!

## How do AVL trees operations maintain logarithmic performance?
- AVL trees maintain logarithmic performance by keeping the tree and all its subtrees balanced within a height difference of two nodes for each nodes left and right subtree. Every time the tree is modified, all of the nodes on the modified path calculate and store their balance factor to make sure the tree follows the balance rules. Looking at my implementation, at the end of each insert and erase call as the recursive function bubbles up to the tree root the balance factor is recalculated at each passing node and if the absolute value of the balance factor is greater than two, the tree applies a rotation to correct the balance issue. While inserting is a more expensive operation than a classic binary search tree, keeping balance results in consistenly performant search operations.

## How does avl_map perform compared to std::map? What are the trade offs?
- As discussed in question one, the two collections performed similarly over the 1000 samples ran in the simulation. While the avl_map performed slightly better overall, the difference is small enough to be unimportant. It makes sense that the two trees would have similar search times since they are both self balancing trees, which guarantees O(log n) time. One thing to note is that since the csv was inserted with keys in ascending order, this will influence where the keys are located when all the values are rotated to maintain balance. It is difficult to say without reading through the entire tree, but I believe this will result in the first keys inserted in the tree and the last trees inserted in the tree to be on the bottom of the tree farthest from the root. I can picture how the avl tree will change to balance, but I do not know how std::map will look after being loaded. Its possible the relative locations of the keys after loading is a factor in why the avl_map is slightly faster. Additionally, the simulation did not include the time taken to grow the tree from its initial empty state, but I imagine this will be more expensive for the avl_map since the calculations are done each insertion. Trees like splay trees do not balance on insertion, depending on how std::map is implemented it may be much faster at insertion than the custom avl_map.